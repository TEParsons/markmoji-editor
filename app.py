import markdown
import time
import threading
import PyQt5.QtWidgets as qt
import PyQt5.QtWebEngineWidgets as html
from markmoji.markmoji import Markmoji




class MarkmojiApp(qt.QApplication):
    def __init__(self, argv=[]):
        qt.QApplication.__init__(
            self, argv
        )
        # set theme
        from .theme import current
        self.theme = current
        # make main window
        self.win = MarkmojiEditor(self)


class MarkmojiEditor(qt.QWidget):
    def __init__(self, app):
        # create
        qt.QWidget.__init__(self)
        self.app = app
        self.sizer = qt.QVBoxLayout(self)
        # setup interpreter
        self.md = markdown.Markdown(
            extensions=["extra", Markmoji()]
        )
        # array to store render times in
        self._render_durs = [0]
        self._last_render = 0

        # setup panel
        self.panel = qt.QSplitter(self)
        self.sizer.addWidget(self.panel)
        # raw text ctrl
        self.raw_ctrl = qt.QTextEdit()
        self.raw_ctrl.setAcceptRichText(False)
        self.panel.addWidget(self.raw_ctrl)
        # rendered HTML ctrl
        self.html_ctrl = html.QWebEngineView()
        self.panel.addWidget(self.html_ctrl)

        # bind rendering to text edit
        self.raw_ctrl.textChanged.connect(self.on_text)

        # show
        self.apply_theme()
        self.show()
    
    def apply_theme(self):
        # set style for app
        # self.setPalette(self.app.theme.app.spec)
        # set stylesheet for raw_ctrl
        pygments_style = self.app.theme.editor.spec
        pygments_css = "font-family: JetBrains Mono; font-size: 14pt;"  # not implimented yet - just use standard value
        self.raw_ctrl.setStyleSheet(pygments_css)
        # render HTML so css is reapplied
        self.render_html()
    
    def on_text(self, evt=None):
        """
        Handle when raw text value is changed.

        #### Args
        evt (qt.QSignal, optional)
        :    Event generated by the `textChanged` event. Defaults to None.
        """
        # if it's been <10 render times since last render, skip
        if time.time() < self._last_render + sum(self._render_durs):
            return
        # render HTML
        threading.Thread(target=self.render_html).run()
        
    
    def render_html(self):
        """
        Render markdown content into HTML
        """
        # start timing
        start = time.time()
        # get markdown
        content_md = self.raw_ctrl.toPlainText()
        # parse to HTML
        content_html = self.md.convert(content_md)
        # apply HTML
        content_html = (
            f"<head>\n"
            f"<style>\n"
            f"{self.app.theme.viewer.spec}\n"
            f"</style>\n"
            f"</head>\n"
            f"<body>\n"
            f"{content_html}\n"
            f"</body>"
        )
        print(content_html)
        self.html_ctrl.setHtml(content_html)
        # store time of this render
        self._last_render = time.time()
        # store render dur
        self._render_durs.append(self._last_render - start)
        # only keep last 10 render durs
        if len(self._render_durs) > 10:
            self._render_durs = self._render_durs[-10:]