import markdown
import time
import threading
import pygments, pygments.lexers
import PyQt5.QtWidgets as qt
import PyQt5.QtGui as gui
import PyQt5.QtWebEngineWidgets as html
import markmoji


class MarkmojiApp(qt.QApplication):
    def __init__(self, show_splash=True, argv=[]):
        qt.QApplication.__init__(
            self, argv
        )
        # show splash (if requested)
        if show_splash:
            splash = qt.QSplashScreen(
                gui.QPixmap('markmoji_editor/assets/Splash.png')
            )
            splash.show()
            splash.start_time = time.time()
        
        # set theme
        from .theme import current
        self.theme = current
        # make main window
        self.win = MarkmojiFrame(self)

        # close splash (if shown)
        if show_splash:    
            while time.time() - self.app.splash.start_time < 2.5:
                pass
            splash.close()

class MarkmojiFrame(qt.QWidget):
    def __init__(self, app):
        # create
        qt.QWidget.__init__(self)
        self.app = app
        # array to store render times in
        self._render_durs = [0]
        self._last_render = 0

        # setup interpreter
        self.md = markdown.Markdown(
            extensions=["extra", markmoji.Markmoji()]
        )

        # setup window
        self.setWindowIcon(gui.QIcon('markmoji_editor/assets/Emblem@16w.png'))
        self.setWindowTitle(f"Markmoji (v{markmoji.__version__})")

        # setup panel
        self.sizer = qt.QVBoxLayout(self)
        self.panel = qt.QSplitter(self)
        self.sizer.addWidget(self.panel)
        # raw text ctrl
        self.raw_ctrl = MarkmojiEditor(frame=self)
        self.panel.addWidget(self.raw_ctrl)
        # rendered HTML ctrl
        self.html_ctrl = html.QWebEngineView()
        self.panel.addWidget(self.html_ctrl)

        # bind rendering to text edit
        self.raw_ctrl.textChanged.connect(self.on_text)

        # show
        self.apply_theme()
        self.show()
    
    def apply_theme(self):
        self.raw_ctrl.style_text()
        # render HTML so css is reapplied
        self.render_html()
    
    def on_text(self, evt=None):
        """
        Handle when raw text value is changed.

        #### Args
        evt (qt.QSignal, optional)
        :    Event generated by the `textChanged` event. Defaults to None.
        """
        # style markdown
        self.raw_ctrl.style_text()
        # render HTML
        threading.Thread(target=self.render_html).run()
    
    def render_html(self):
        """
        Render markdown content into HTML
        """
        # start timing
        start = time.time()
        # get markdown
        content_md = self.raw_ctrl.toPlainText()
        # parse to HTML
        content_html = self.md.convert(content_md)
        # apply HTML
        content_html = (
            f"<head>\n"
            f"<style>\n"
            f"{self.app.theme.viewer.spec}\n"
            f"</style>\n"
            f"</head>\n"
            f"<body>\n"
            f"{content_html}\n"
            f"</body>"
        )
        self.html_ctrl.setHtml(content_html)
        # store time of this render
        self._last_render = time.time()
        # store render dur
        self._render_durs.append(self._last_render - start)
        # only keep last 10 render durs
        if len(self._render_durs) > 10:
            self._render_durs = self._render_durs[-10:]


class MarkmojiEditor(qt.QTextEdit):
    def __init__(self, frame):
        # initialise
        qt.QTextEdit.__init__(self)
        self.setAcceptRichText(False)
        self.frame = frame
        self.app = self.frame.app
        
        # setup lexer
        self.lexer = pygments.lexers.get_lexer_by_name("markdown")

    def style_text(self):
        """
        Apply pyments.style to text contents
        """
        # don't trigger any events while this method executes
        self.blockSignals(True)

        # get cursor handle
        cursor = gui.QTextCursor(self.document())
        # get style dict
        style = self.app.theme.editor.spec
        # set base style
        self.setStyleSheet(
            f"background-color: {style.background_color};"
            f"color: #{style.style_for_token(pygments.token.Token)['color']};"
            f"font-family: JetBrains Mono;"
            f"font-size: 14pt;"
        )
        # lex content to get tokens
        tokens = pygments.lex(self.toPlainText(), lexer=self.lexer)
        # re-add characters with styling
        i = 0
        for token, text in tokens:
            # get style for this token
            token_style = style.style_for_token(token)
            # create format object
            char_format = gui.QTextCharFormat()
            char_format.setFontItalic(token_style['italic'])
            char_format.setFontWeight(600 if token_style['bold'] else 400)
            char_format.setFontUnderline(token_style['underline'])
            # select corresponding chars
            cursor.setPosition(i)
            cursor.movePosition(cursor.Right, n=len(text), mode=cursor.KeepAnchor)
            # format selection
            cursor.setCharFormat(char_format)
            # move forward to next token
            i += len(text)

        # allow signals to trigger again
        self.blockSignals(False)
