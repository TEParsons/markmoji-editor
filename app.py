import markdown
import time
import threading
import traceback
import pygments, pygments.lexers
import PyQt5.QtCore as util
import PyQt5.QtWidgets as qt
import PyQt5.QtGui as gui
import PyQt5.QtWebEngineWidgets as html
import markmoji


class MarkmojiApp(qt.QApplication):
    def __init__(self, show_splash=True, argv=[]):
        qt.QApplication.__init__(
            self, argv
        )
        # show splash (if requested)
        if show_splash:
            splash = qt.QSplashScreen(
                gui.QPixmap('markmoji_editor/assets/Splash.png')
            )
            splash.show()
            splash.start_time = time.time()
        
        # set theme
        from .theme import current
        self.theme = current
        # make main window
        self.win = MarkmojiFrame(self)

        # close splash (if shown)
        if show_splash:    
            while time.time() - self.app.splash.start_time < 2.5:
                pass
            splash.close()

class MarkmojiFrame(qt.QWidget):
    def __init__(self, app):
        # create
        qt.QWidget.__init__(self)
        self.app = app
        # array to store render times in
        self._render_durs = [0]
        self._last_render = 0

        # setup interpreter
        self.md = markdown.Markdown(
            extensions=["extra", markmoji.Markmoji()]
        )

        # setup window
        self.setWindowIcon(gui.QIcon('markmoji_editor/assets/Emblem@16w.png'))
        self.setWindowTitle(f"Markmoji (v{markmoji.__version__})")
        self.sizer = qt.QVBoxLayout(self)

        # setup panel
        self.panel = qt.QSplitter(self)
        self.panel.setChildrenCollapsible(False)
        self.sizer.addWidget(self.panel)
        # raw text ctrl
        self.md_ctrl = MarkmojiEditor(frame=self)
        self.panel.addWidget(self.md_ctrl)
        # raw html ctrl
        self.html_ctrl = HTMLReader(frame=self)
        self.panel.addWidget(self.html_ctrl)
        # rendered HTML ctrl
        self.html_view = html.QWebEngineView()
        self.html_view.setMinimumWidth(128)
        self.panel.addWidget(self.html_view)

        # bind rendering to text edit
        self.md_ctrl.textChanged.connect(self.on_text)

        # add view toggle
        self.view_ctrl = qt.QWidget(self)
        self.view_ctrl.setMaximumHeight(48)
        self.view_ctrl.sizer = qt.QHBoxLayout(self.view_ctrl)
        self.sizer.addWidget(self.view_ctrl, alignment=util.Qt.AlignHCenter)
        # markdown button
        self.md_btn = qt.QPushButton("", self)
        self.md_btn.setIcon(gui.QIcon('markmoji_editor/assets/icons/view_md.svg'))
        self.md_btn.setIconSize(util.QSize(16, 16))
        self.md_btn.setMaximumSize(48, 32)
        self.md_btn.setCheckable(True)
        self.md_btn.clicked.connect(self.toggle_md)
        self.view_ctrl.sizer.addWidget(self.md_btn)
        # html button
        self.html_btn = qt.QPushButton("", self)
        self.html_btn.setIcon(gui.QIcon('markmoji_editor/assets/icons/view_html.svg'))
        self.html_btn.setIconSize(util.QSize(16, 16))
        self.html_btn.setMaximumSize(48, 32)
        self.html_btn.setCheckable(True)
        self.html_btn.clicked.connect(self.toggle_html)
        self.view_ctrl.sizer.addWidget(self.html_btn)
        # preview button
        self.view_btn = qt.QPushButton("", self)
        self.view_btn.setIcon(gui.QIcon('markmoji_editor/assets/icons/view_preview.svg'))
        self.view_btn.setIconSize(util.QSize(16, 16))
        self.view_btn.setMaximumSize(48, 32)
        self.view_btn.setCheckable(True)
        self.view_btn.clicked.connect(self.toggle_view)
        self.view_ctrl.sizer.addWidget(self.view_btn)

        # apply start layout
        self.md_btn.setChecked(True)
        self.toggle_md()
        self.html_btn.setChecked(False)
        self.toggle_html()
        self.view_btn.setChecked(True)
        self.toggle_view()

        # show
        self.apply_theme()
        self.show()
    
    def apply_theme(self):
        self.md_ctrl.style_text()
        # render HTML so css is reapplied
        self.render_html()
    
    def on_text(self, evt=None):
        """
        Handle when raw text value is changed.

        #### Args
        evt (qt.QSignal, optional)
        :    Event generated by the `textChanged` event. Defaults to None.
        """
        # style markdown
        self.md_ctrl.style_text()
        # render HTML
        threading.Thread(target=self.render_html).run()
    
    def render_html(self):
        """
        Render markdown content into HTML
        """
        # start timing
        start = time.time()
        # get markdown
        content_md = self.md_ctrl.toPlainText()
        # parse to HTML
        try:
            content_html = self.md.convert(content_md)
        except Exception as err:
            tb = "\n".join(traceback.format_exception(err))
            content_html = (
                f"<h1>Error</h1>\n"
                f"<p>Could not parse Markdown. Error from Python:</p>\n"
                f"<pre><code>{tb}</code></pre>\n"
                )
        # apply HTML
        self.html_ctrl.setPlainText(content_html)
        self.html_ctrl.style_text()
        # preview HTML
        content_html = (
            f"<head>\n"
            f"<style>\n"
            f"{self.app.theme.viewer.spec}\n"
            f"</style>\n"
            f"</head>\n"
            f"<body>\n"
            f"{content_html}\n"
            f"</body>"
        )
        self.html_view.setHtml(content_html)
        # store time of this render
        self._last_render = time.time()
        # store render dur
        self._render_durs.append(self._last_render - start)
        # only keep last 10 render durs
        if len(self._render_durs) > 10:
            self._render_durs = self._render_durs[-10:]
    
    def toggle_md(self, evt=None):
        if self.md_btn.isChecked():
            self.md_ctrl.show()
        else:
            self.md_ctrl.hide()
    
    def toggle_html(self, evt=None):
        if self.html_btn.isChecked():
            self.html_ctrl.show()
        else:
            self.html_ctrl.hide()
    
    def toggle_view(self, evt=None):
        if self.view_btn.isChecked():
            self.html_view.show()
        else:
            self.html_view.hide()


class StyledTextCtrl(qt.QTextEdit):
    def __init__(self, frame, language):
                # initialise
        qt.QTextEdit.__init__(self)
        self.setAcceptRichText(False)
        self.setMinimumWidth(128)
        self.frame = frame
        self.app = self.frame.app
        # setup lexer
        self.lexer = pygments.lexers.get_lexer_by_name(language)
        # setup right click
        self.setContextMenuPolicy(util.Qt.CustomContextMenu)
        self.customContextMenuRequested.connect(self.on_context_menu)
    
    def on_context_menu(self):
        # setup menu style
        style = self.app.theme.editor.spec
        stylesheet = (
            f"QMenu::item{{"
            f"   background-color: {style.background_color};"
            f"   color: #{style.style_for_token(pygments.token.Token)['color']};"
            f"   font-family: JetBrains Mono,Noto Emoji;"
            f"}}"

            f"QMenu::item:selected{{"
            f"   background-color: {style.line_number_background_color};"
            f"   color: {style.line_number_color};"
            f"}}"
        )
        # make menu
        menu = self.createStandardContextMenu()
        menu.setStyleSheet(stylesheet)
        # add emoji section
        menu.addSeparator()
        submenu = menu.addMenu("Insert &Handler")
        submenu.setStyleSheet(stylesheet)
        # add emojis
        for emoji, cls in markmoji.handlers.map.items():
            # skip base classes
            if emoji in ("?", "〽️", "❓"):
                continue
            # add emoji
            submenu.addAction(f"{emoji} {cls.__name__}", self.insert_emoji)
            
        menu.exec_(gui.QCursor.pos())
    
    def insert_emoji(self, evt=None):
        # get emoji
        text = self.sender().text()
        emoji = text.split(" ")[0]
        # insert emoji
        self.insertPlainText(emoji + "[]()")
    
    def style_text(self):
        """
        Apply pyments.style to text contents
        """
        # don't trigger any events while this method executes
        self.blockSignals(True)

        # get cursor handle
        cursor = gui.QTextCursor(self.document())
        # get style dict
        style = self.app.theme.editor.spec
        # set base style
        self.setStyleSheet(
            f"background-color: {style.background_color};"
            f"font-family: JetBrains Mono, Noto Emoji;"
            f"font-size: 14pt;"
        )
        # lex content to get tokens
        tokens = pygments.lex(self.toPlainText(), lexer=self.lexer)
        # re-add characters with styling
        i = 0
        for token, text in tokens:
            # get style for this token
            token_style = style.style_for_token(token)
            # create format object
            char_format = gui.QTextCharFormat()
            char_format.setFontFamily("JetBrains Mono")
            char_format.setFontItalic(token_style['italic'])
            if token_style['bold']:
                char_format.setFontWeight(600)
            char_format.setFontUnderline(token_style['underline'])
            char_format.setForeground(gui.QColor("#" + token_style['color']))
            # select corresponding chars
            cursor.setPosition(i)
            cursor.movePosition(cursor.Right, n=len(text), mode=cursor.KeepAnchor)
            # format selection
            cursor.setCharFormat(char_format)
            # move forward to next token
            i += len(text)

        # allow signals to trigger again
        self.blockSignals(False)


class MarkmojiEditor(StyledTextCtrl):
    def __init__(self, frame):
        StyledTextCtrl.__init__(self, frame, language="markdown")
        
        
class HTMLReader(StyledTextCtrl):
    def __init__(self, frame):
        StyledTextCtrl.__init__(self, frame, language="html")
        self.setReadOnly(True)
    
